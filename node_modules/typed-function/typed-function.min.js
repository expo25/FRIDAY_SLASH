"use strict";!function(n,e){"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?module.exports=e():n.typed=e()}(this,function(){function P(){return!0}function yn(){return!1}function gn(){}const M="Argument is not a typed-function.";return function n(){function l(n){return"object"==typeof n&&null!==n&&n.constructor===Object}var e=[{name:"number",test:function(n){return"number"==typeof n}},{name:"string",test:function(n){return"string"==typeof n}},{name:"boolean",test:function(n){return"boolean"==typeof n}},{name:"Function",test:function(n){return"function"==typeof n}},{name:"Array",test:Array.isArray},{name:"Date",test:function(n){return n instanceof Date}},{name:"RegExp",test:function(n){return n instanceof RegExp}},{name:"Object",test:l},{name:"null",test:function(n){return null===n}},{name:"undefined",test:function(n){return void 0===n}}];const t={name:"any",test:P,isAny:!0};let i,s,r=0,en={createCount:0};function f(n){var e=i.get(n);if(e)return e;let t='Unknown type "'+n+'"';var r=n.toLowerCase();let o;for(o of s)if(o.toLowerCase()===r){t+='. Did you mean "'+o+'" ?';break}throw new TypeError(t)}function o(n,e="any"){var t=e?f(e).index:s.length;const r=[];for(var o=0;o<n.length;++o){if(!n[o]||"string"!=typeof n[o].name||"function"!=typeof n[o].test)throw new TypeError("Object with properties {name: string, test: function} expected");var a=n[o].name;if(i.has(a))throw new TypeError('Duplicate type name "'+a+'"');r.push(a),i.set(a,{name:a,test:n[o].test,isAny:n[o].isAny,index:t+o,conversionsTo:[]})}for(e=s.slice(t),s=s.slice(0,t).concat(r).concat(e),o=t+r.length;o<s.length;++o)i.get(s[o]).index=o}function a(){i=new Map,s=[],r=0,o([t],!1)}function p(t){var n=s.filter(n=>{const e=i.get(n);return!e.isAny&&e.test(t)});return n.length?n:["any"]}function h(n){return n&&"function"==typeof n&&"_typedFunctionData"in n}function c(e,n,t){if(!h(e))throw new TypeError(M);var t=t&&t.exact,r=rn(Array.isArray(n)?n.join(","):n),n=tn(r);if((!t||n in e.signatures)&&(n=e._typedFunctionData.signatureMap.get(n)))return n;var o=r.length;let a;if(t){a=[];let n;for(n in e.signatures)a.push(e._typedFunctionData.signatureMap.get(n))}else a=e._typedFunctionData.signatures;for(var i=0;i<o;++i){const c=r[i],u=[];let n;for(n of a){var s=y(n.params,i);if(s&&(!c.restParam||s.restParam)){if(!s.hasAny){const l=m(s);if(c.types.some(n=>!l.has(n.name)))continue}u.push(n)}}if(0===(a=u).length)break}let f;for(f of a)if(f.params.length<=o)return f;throw new TypeError("Signature not found (signature: "+(e.name||"unnamed")+"("+tn(r,", ")+"))")}function tn(n,e=","){return n.map(n=>n.name).join(e)}function cn(n){const e=function(n){if(0===n.length)return[];const e=n.map(f);1<n.length&&e.sort((n,e)=>n.index-e.index);let t=e[0].conversionsTo;if(1!==n.length){t=t.concat([]);const o=new Set(n);for(var r=1;r<e.length;++r){let n;for(n of e[r].conversionsTo)o.has(n.from)||(t.push(n),o.add(n.from))}}return t}(n.types.map(n=>n.name));let t=n.hasAny,r=n.name;var o=e.map(function(n){var e=f(n.from);return t=e.isAny||t,r+="|"+n.from,{name:n.from,typeIndex:e.index,test:e.test,isAny:e.isAny,conversion:n,conversionIndex:n.index}});return{types:n.types.concat(o),name:r,hasAny:t,hasConversion:0<o.length,restParam:n.restParam}}function m(e){return e.typeSet||(e.typeSet=new Set,e.types.forEach(n=>e.typeSet.add(n.name))),e.typeSet}function rn(n){const e=[];if("string"!=typeof n)throw new TypeError("Signatures must be strings");const t=n.trim();if(""!==t){const a=t.split(",");for(var r=0;r<a.length;++r){var o=function(n){var e=0===n.indexOf("...");const t=e?3<n.length?n.slice(3):"any":n,r=t.split("|").map(n=>f(n.trim()));let o=!1,a=e?"...":"";return{types:r.map(function(n){return o=n.isAny||o,a+=n.name+"|",{name:n.name,typeIndex:n.index,test:n.test,isAny:n.isAny,conversion:null,conversionIndex:-1}}),name:a.slice(0,-1),hasAny:o,hasConversion:!1,restParam:e}}(a[r].trim());if(o.restParam&&r!==a.length-1)throw new SyntaxError('Unexpected rest parameter "'+a[r]+'": only allowed for the last parameter');if(0==o.types.length)return null;e.push(o)}}return e}function on(n){return!!(n=A(n))&&n.restParam}function an(n){if(n&&0!==n.types.length){if(1===n.types.length)return f(n.types[0].name).test;if(2===n.types.length){const e=f(n.types[0].name).test,t=f(n.types[1].name).test;return function(n){return e(n)||t(n)}}{const r=n.types.map(function(n){return f(n.name).test});return function(n){for(var e=0;e<r.length;e++)if(r[e](n))return!0;return!1}}}return P}function un(n){let t,e,r;if(on(n)){const o=(t=x(n).map(an)).length,a=an(A(n));return function(n){for(var e=0;e<t.length;e++)if(!t[e](n[e]))return!1;return function(n){for(var e=o;e<n.length;e++)if(!a(n[e]))return!1;return!0}(n)&&n.length>=o+1}}return 0===n.length?function(n){return 0===n.length}:1===n.length?(e=an(n[0]),function(n){return e(n[0])&&1===n.length}):2===n.length?(e=an(n[0]),r=an(n[1]),function(n){return e(n[0])&&r(n[1])&&2===n.length}):(t=n.map(an),function(n){for(var e=0;e<t.length;e++)if(!t[e](n[e]))return!1;return n.length===t.length})}function y(n,e){return e<n.length?n[e]:on(n)?A(n):null}function sn(n,e){return(n=y(n,e))?m(n):new Set}function u(n){return null===n.conversion||void 0===n.conversion}function g(n,t){const r=new Set;return n.forEach(n=>{let e;for(e of sn(n.params,t))r.add(e)}),r.has("any")?["any"]:Array.from(r)}function d(n,t,e){let r,o;var a=n||"unnamed";let i=e;for(var s=0;s<t.length;s++){const c=[];if(i.forEach(n=>{const e=an(y(n.params,s));(s<n.params.length||on(n.params))&&e(t[s])&&c.push(n)}),0===c.length){if(0<(o=g(i,s)).length){const u=p(t[s]);return(r=new TypeError("Unexpected type of argument in function "+a+" (expected: "+o.join(" or ")+", actual: "+u.join(" | ")+", index: "+s+")")).data={category:"wrongType",fn:a,index:s,actual:u,expected:o},r}}else i=c}if(n=i.map(function(n){return on(n.params)?1/0:n.params.length}),t.length<Math.min.apply(null,n))o=g(i,s),(r=new TypeError("Too few arguments in function "+a+" (expected: "+o.join(" or ")+", index: "+t.length+")")).data={category:"tooFewArgs",fn:a,index:t.length,expected:o};else if(e=Math.max.apply(null,n),t.length>e)(r=new TypeError("Too many arguments in function "+a+" (expected: "+e+", actual: "+t.length+")")).data={category:"tooManyArgs",fn:a,index:t.length,expectedLength:e};else{const l=[];for(var f=0;f<t.length;++f)l.push(p(t[f]).join("|"));(r=new TypeError('Arguments of type "'+l.join(", ")+'" do not match any of the defined signatures of function '+a+".")).data={category:"mismatch",actual:l}}return r}function v(n){let e=s.length+1;for(var t=0;t<n.types.length;t++)u(n.types[t])&&(e=Math.min(e,n.types[t].typeIndex));return e}function w(n){let e=r+1;for(var t=0;t<n.types.length;t++)u(n.types[t])||(e=Math.min(e,n.types[t].conversionIndex));return e}function ln(n,e){var t=n.params,r=e.params,n=A(t),e=A(r),o=on(t),a=on(r);if(o&&n.hasAny){if(!a||!e.hasAny)return 1}else if(a&&e.hasAny)return-1;let i=0,s=0,f;for(f of t)f.hasAny&&++i,f.hasConversion&&++s;let c=0,u=0;for(f of r)f.hasAny&&++c,f.hasConversion&&++u;if(i!==c)return i-c;if(o&&n.hasConversion){if(!a||!e.hasConversion)return 1}else if(a&&e.hasConversion)return-1;if(s!==u)return s-u;if(o){if(!a)return 1}else if(a)return-1;if(0!=(n=(t.length-r.length)*(o?-1:1)))return n;const l=[];let p=0;for(let n=0;n<t.length;++n){var h=function(n,e){if(n.hasAny){if(!e.hasAny)return 1}else if(e.hasAny)return-1;if(n.restParam){if(!e.restParam)return 1}else if(e.restParam)return-1;if(n.hasConversion){if(!e.hasConversion)return 1}else if(e.hasConversion)return-1;var t=v(n)-v(e);return t<0?-1:0<t?1:(t=w(n)-w(e))<0?-1:0<t?1:0}(t[n],r[n]);l.push(h),p+=h}if(0!==p)return p;let m;for(m of l)if(0!==m)return m;return 0}function pn(n){let e,t,r,o;const a=[],i=[];switch(n.types.forEach(function(n){n.conversion&&(a.push(f(n.conversion.from).test),i.push(n.conversion.convert))}),i.length){case 0:return function(n){return n};case 1:return e=a[0],r=i[0],function(n){return e(n)?r(n):n};case 2:return e=a[0],t=a[1],r=i[0],o=i[1],function(n){return e(n)?r(n):t(n)?o(n):n};default:return function(n){for(var e=0;e<i.length;e++)if(a[e](n))return i[e](n);return n}}}function hn(n){return function e(t,r,o){if(r<t.length){const s=t[r];let n=[];if(s.restParam){const f=s.types.filter(u);f.length<s.types.length&&n.push({types:f,name:"..."+f.map(n=>n.name).join("|"),hasAny:f.some(n=>n.isAny),hasConversion:!1,restParam:!0}),n.push(s)}else n=s.types.map(function(n){return{types:[n],name:n.name,hasAny:n.isAny,hasConversion:n.conversion,restParam:!1}});return a=n,i=function(n){return e(t,r+1,o.concat([n]))},Array.prototype.concat.apply([],a.map(i))}return[o];var a,i}(n,0,[])}function mn(n,e,t){let r=n.map(n=>S(n)?b(n.referToSelf.callback):C(n)?E(n.referTo.references,n.referTo.callback):n),o=new Array(r.length).fill(!1),a=!0;for(;a;){let n=!(a=!1);for(var i,s=0;s<r.length;++s)if(!o[s]){const f=r[s];S(f)?(r[s]=f.referToSelf.callback(t),r[s].referToSelf=f.referToSelf,o[s]=!0,n=!1):C(f)&&((i=function(n,e,t){const r=[];let o;for(o of n){var a=t[o];if("number"!=typeof a)throw new TypeError('No definition for referenced signature "'+o+'"');if("function"!=typeof(a=e[a]))return!1;r.push(a)}return r}(f.referTo.references,r,e))?(r[s]=f.referTo.callback.apply(this,i),r[s].referTo=f.referTo,o[s]=!0,n=!1):a=!0)}if(n&&a)throw new SyntaxError("Circular reference detected in resolving typed.referTo")}return r}function O(e,t){if(en.createCount++,0===Object.keys(t).length)throw new SyntaxError("No signatures provided");var r,o;en.warnAgainstDeprecatedThis&&(r=t,o=/\bthis(\(|\.signatures\b)/,Object.keys(r).forEach(n=>{if(n=r[n],o.test(n.toString()))throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.")}));const a=[],i=[],s={},f=[];let c;for(c in t)if(Object.prototype.hasOwnProperty.call(t,c)){const _=rn(c);if(_){a.forEach(function(n){if(function(t,r){for(var n=Math.max(t.length,r.length),o=0;o<n;o++){const f=sn(t,o);let n=!1,e;for(e of sn(r,o))if(f.has(e)){n=!0;break}if(!n)return}var e=t.length,a=r.length,i=on(t),s=on(r);return i?s?e===a:e<=a:s?a<=e:e===a}(n,_))throw new TypeError('Conflicting signatures "'+tn(n)+'" and "'+tn(_)+'".')}),a.push(_);var u=i.length,l=(i.push(t[c]),_.map(cn));let n;for(n of hn(l)){var p=tn(n);f.push({params:n,name:p,fn:u}),n.every(n=>!n.hasConversion)&&(s[p]=u)}}}f.sort(ln);var n=mn(i,s,I);let h;for(h in s)Object.prototype.hasOwnProperty.call(s,h)&&(s[h]=n[s[h]]);const m=[],y=new Map;for(h of f)y.has(h.name)||(h.fn=n[h.fn],m.push(h),y.set(h.name,h));for(var g=m[0]&&m[0].params.length<=2&&!on(m[0].params),d=m[1]&&m[1].params.length<=2&&!on(m[1].params),v=m[2]&&m[2].params.length<=2&&!on(m[2].params),w=m[3]&&m[3].params.length<=2&&!on(m[3].params),T=m[4]&&m[4].params.length<=2&&!on(m[4].params),x=m[5]&&m[5].params.length<=2&&!on(m[5].params),A=g&&d&&v&&w&&T&&x,E=0;E<m.length;++E)m[E].test=un(m[E].params);const b=g?an(m[0].params[0]):yn,C=d?an(m[1].params[0]):yn,S=v?an(m[2].params[0]):yn,j=w?an(m[3].params[0]):yn,k=T?an(m[4].params[0]):yn,O=x?an(m[5].params[0]):yn,P=g?an(m[0].params[1]):yn,M=d?an(m[1].params[1]):yn,D=v?an(m[2].params[1]):yn,F=w?an(m[3].params[1]):yn,U=T?an(m[4].params[1]):yn,L=x?an(m[5].params[1]):yn;for(E=0;E<m.length;++E)m[E].implementation=function(n,r){let e=r;if(n.some(n=>n.hasConversion)){const o=on(n),a=n.map(pn);e=function(){const n=[];for(var e=o?arguments.length-1:arguments.length,t=0;t<e;t++)n[t]=a[t](arguments[t]);return o&&(n[e]=arguments[e].map(a[e])),r.apply(this,n)}}let t=e;if(on(n)){const i=n.length-1;t=function(){return e.apply(this,fn(arguments,0,i).concat([fn(arguments,i)]))}}return t}(m[E].params,m[E].fn);const N=g?m[0].implementation:gn,R=d?m[1].implementation:gn,q=v?m[2].implementation:gn,z=w?m[3].implementation:gn,B=T?m[4].implementation:gn,G=x?m[5].implementation:gn,H=g?m[0].params.length:-1,J=d?m[1].params.length:-1,K=v?m[2].params.length:-1,Q=w?m[3].params.length:-1,V=T?m[4].params.length:-1,W=x?m[5].params.length:-1,X=A?6:0,Y=m.length,Z=m.map(n=>n.test),$=m.map(n=>n.implementation),nn=function(){for(var n=X;n<Y;n++)if(Z[n](arguments))return $[n].apply(this,arguments);return en.onMismatch(e,arguments,m)};function I(n,e){return(arguments.length===H&&b(n)&&P(e)?N:arguments.length===J&&C(n)&&M(e)?R:arguments.length===K&&S(n)&&D(e)?q:arguments.length===Q&&j(n)&&F(e)?z:arguments.length===V&&k(n)&&U(e)?B:arguments.length===W&&O(n)&&L(e)?G:nn).apply(this,arguments)}try{Object.defineProperty(I,"name",{value:e})}catch(n){}return I.signatures=s,I._typedFunctionData={signatures:m,signatureMap:y},I}function T(n,e,t){throw d(n,e,t)}function x(n){return fn(n,0,n.length-1)}function A(n){return n[n.length-1]}function fn(n,e,t){return Array.prototype.slice.call(n,e,t)}function E(n,e){return{referTo:{references:n,callback:e}}}function b(n){if("function"!=typeof n)throw new TypeError("Callback function expected as first argument");return{referToSelf:{callback:n}}}function C(n){return n&&"object"==typeof n.referTo&&Array.isArray(n.referTo.references)&&"function"==typeof n.referTo.callback}function S(n){return n&&"object"==typeof n.referToSelf&&"function"==typeof n.referToSelf.callback}function j(n,e){if(!n)return e;if(e&&e!=n){const t=new Error("Function names do not match (expected: "+n+", actual: "+e+")");throw t.data={actual:e,expected:n},t}return n}a(),o(e);e=en;function k(n){if(!n||"string"!=typeof n.from||"string"!=typeof n.to||"function"!=typeof n.convert)throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");if(n.to===n.from)throw new SyntaxError('Illegal to define conversion from "'+n.from+'" to itself.')}return(en=function(n){var r="string"==typeof n;let o=r?n:"";var a={};for(let t=r?1:0;t<arguments.length;++t){var i=arguments[t];let e={},n;if("function"==typeof i?(n=i.name,"string"==typeof i.signature?e[i.signature]=i:h(i)&&(e=i.signatures)):l(i)&&(e=i,r||(n=function(n){let e;for(var t in n)n.hasOwnProperty(t)&&(h(n[t])||"string"==typeof n[t].signature)&&(e=j(e,n[t].name));return e}(i))),0===Object.keys(e).length){const c=new TypeError("Argument to 'typed' at index "+t+" is not a (typed) function, nor an object with signatures as keys and functions as values.");throw c.data={index:t,argument:i},c}r||(o=j(o,n));{f=s=void 0;var s=a,f=e;let n;for(n in f)if(f.hasOwnProperty(n)){if(n in s&&f[n]!==s[n]){const u=new Error('Signature "'+n+'" is defined twice');throw u.data={signature:n,sourceFunction:f[n],destFunction:s[n]},u}s[n]=f[n]}}}return O(o||"",a)}).create=n,en.createCount=e.createCount,en.onMismatch=T,en.throwMismatchError=T,en.createError=d,en.clear=a,en.clearConversions=function(){let n;for(n of s)i.get(n).conversionsTo=[];r=0},en.addTypes=o,en._findType=f,en.referTo=function(){var n=x(arguments).map(n=>tn(rn(n))),e=A(arguments);if("function"!=typeof e)throw new TypeError("Callback function expected as last argument");return E(n,e)},en.referToSelf=b,en.convert=function(n,e){const t=f(e);if(t.test(n))return n;const r=t.conversionsTo;if(0===r.length)throw new Error("There are no conversions to "+e+" defined.");for(var o=0;o<r.length;o++){const a=f(r[o].from);if(a.test(n))return r[o].convert(n)}throw new Error("Cannot convert "+n+" to "+e)},en.findSignature=c,en.find=function(n,e,t){return c(n,e,t).implementation},en.isTypedFunction=h,en.warnAgainstDeprecatedThis=!0,en.addType=function(n,e){let t="any";!1!==e&&i.has("Object")&&(t="Object"),en.addTypes([n],t)},en.addConversion=function(e){k(e);const n=f(e.to);if(!n.conversionsTo.every(function(n){return n.from!==e.from}))throw new Error('There is already a conversion from "'+e.from+'" to "'+n.name+'"');n.conversionsTo.push({from:e.from,convert:e.convert,index:r++})},en.addConversions=function(n){n.forEach(en.addConversion)},en.removeConversion=function(e){k(e);const n=f(e.to);var t=function(n,e){for(var t=0;t<n.length;t++)if(e(n[t]))return n[t]}(n.conversionsTo,n=>n.from===e.from);if(!t)throw new Error("Attempt to remove nonexistent conversion from "+e.from+" to "+e.to);if(t.convert!==e.convert)throw new Error("Conversion to remove does not match existing conversion");t=n.conversionsTo.indexOf(t),n.conversionsTo.splice(t,1)},en.resolve=function(n,e){if(!h(n))throw new TypeError(M);const t=n._typedFunctionData.signatures;for(var r=0;r<t.length;++r)if(t[r].test(e))return t[r];return null},en}()});